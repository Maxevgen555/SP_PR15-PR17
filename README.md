Лабораторная работа №13-14

Вариант №3
 РЕСУРСЫ WINDOWS-ПРИЛОЖЕНИЙ
Цели лабораторной работы:

Научиться создавать и подключать ресурсы оконного приложения

1.	Научиться создавать и использовать ресурсы типа "значок", "курсор", "меню" и "таблица акселераторов".
2.	Освоить динамическое создание и управление меню.
3.	Научиться использовать взломщики сообщений и макро HANDLE_MSG

Выполнение работы:
Создать приложение с главным окном, своим значком, своим изображением курсора и собственной обработкой сообщений WM_CREATE, WM_DESTROY, WM_PAINT, WM_LBUTTONDOWN (взять из предыдущего проекта).
1.	Создайте пустой проект типа Win32 API c именем SP_PR3. 
Используйте исходные файлы предыдущего проекта. Для этого с помощью файлового менеджера в папку проекта скопируйте файлы исходных текстов(.cpp) и заголовочные файлы(.h) из проекта предыдущей лабораторной работы SP_PR2. Переименуйте скопированные файлы в sp_pr3.cpp и sp_pr3.h. Добавьте файлы к проекту. Выполните компиляцию и компоновку. Убедитесь в работоспособности полученной программы.
 
2.	Добавьте к проекту новый файл - файл описания ресурсов sp_pr3.rc. 

3.	Создайте ресурс типа «значок». В окне редактора значков сформируйте изображение значка размером 32х32. 
 
4.	Внесите изменения в программу для использования созданного ресурса в качестве значка приложения. 
Для этого необходимо значение дескриптора значка присвоить полю hIcon структуры WNDCLASSEX. Сделать это можно, например, так
wc.hIcon = LoadIcon( hInstance, MAKEINTRESOURCE(IDI_ICON1));
Первый параметр функции LoadIcon указывает на местонахождение ресурса. В нашем случае это собственно исполнимый файл приложения и ссылкой на него служит дескриптор, передаваемый в первом параметре функции WinMain. Второй параметр LoadIcon идентифицирует сам ресурс.
Создав и запустив на выполнение программу, можно увидеть значок в левом вернем углу окна приложения и внизу на панели задач. Размер этих изображений 16х16 и они формируются Windows из стандартного изображения (32х32).
 

Задание 2. Ресурсы типа "меню" и "таблица акселераторов" 
Задача. В приложение, полученное в результате выполнения Задания1, добавить меню, обработку WM_COMMAND для меню и клавиши быстрого доступа (акселераторы).
Выполнение:
7. Создан ресурс меню следующего вида: Главное меню содержит подменю “Файл”, “Правка”, “Справка”. Подменю “Файл” содержит команды “Создать”, “Открыть”, “Выход”. Последняя команда отделена от других «разделителем». Подменю “Правка” содержит команды “Выделить”, “Вырезать”, “Копировать”, “Вставить”. Команды этого меню установлены в состояние «недоступные». Подменю “Справка” содержит команды “Помощь”, “О программе…”. 
8. Подключение меню. 
a). Подключено меню к программе через структуру класса окна. 
б). Подключено меню к программе через функцию создания окна CreateWindowEx.
9. Добавлена обработка сообщений меню. Внутри блока обработчика WM_COMMAND предусмотрен оператор switch для ветвления по идентификатору команды меню. Сообщение выводится с помощью системного вызова MessageBox. Для ветви default оператора switch предусмотрен вывод сообщения “Команда с идентификатором ZZZ не реализована”, где ZZZ – код идентификатора, для которого в WM_COMMAND не предусмотрен блок case (значение младшего слова wParam).
10. Создание акселераторов. Добавлены в приложение несколько сочетаний клавиш быстрого доступа (акселераторов) и обеспечена их обработка. Таблица акселераторов создана в виде ресурса приложения.
11. Вывод подсказок о назначении команд. Обеспечен вывод подсказок в главном окне при выделении команд меню (сообщение WM_MENUSELECT). Текст подсказки расположен на 30 пикселей выше нижней границы окна. 
 
Задание 3. Динамическое создание и управление меню
Операции с меню
1. При инициализации приложения (в обработчике WM_CREATE) обеспечена вставка программным путем команды “Закрыть документ” в меню “Файл” .
2. Обеспечена обработка при которой после активации команды “Файл -> Создать” будет становиться доступной команда “Выделить” в меню “Правка”
3. Обеспечена после ввода команды “Правка -> Выделить” доступность команды “Правка -> Копировать” .
4. После ввода команды “Файл-> Закрыть документ” становятся недоступными все команды меню “Правка”.
Контекстное меню
По щелчку правой кнопки мыши в главном окне создается плавающее меню с командами “Выделить” и “Копировать”. Состояние этих команд соответствует состоянию таких же команд в основном меню. 

 
Задание 4. Использование HANDLE_MSG для упрощения структуры оконной процедуры.
 
Построенный код приложения преобразован с использованием макро HANDLE_MSG и “взломщиков сообщений”(Message Crakers) 

https://github.com/Maxevgen555/SP_PR13
При работе использовались ии-агенты https://chat.deepseek.com/ и copilot.

Вывод: 
В процессе выполнения лабораторной работы я научился с помощью кода создавать обработки сообщений в приложении с графическим интерфейсом, обеспечивать перерисовку окна, выводить текст в окно посредством обработки сообщений мыши, создавать элементы управления в главном окне, обработки извещения WM_COMMAND.






Лабораторная работа №15 

Вариант №3
 Диалоговые окна. Элементы управления в диалоговых окнах

Цели лабораторной работы:
Изучение вопросов применения диалоговых панелей для организации пользовательского интерфейса приложения. Получение навыков создания и применения в приложении пользовательских и стандартных диалоговых окон.

Задание:
1.       Создать и проверить работу типового Win32 API приложения создаваемого мастером C++ проектов Win32 API настольных приложений при выключенной кнопке «Пустой проект». Внимательно рассмотреть построенный мастером код и созданные ресурсы приложения. Полученный опыт использовать при выполнении следующих пунктов задания.
2.       Создать и проверить работу модального диалогового окна «О программе…» В диалоговом окне должны отображаться:
      – иконка – логотип программы;
      – сведения о программе – название, цель;
      – сведения о разработчике – фамилия, инициалы, группа;
      – текущие дата и время.
3.       Создать и проверить работу модального диалогового окна, осуществляющего отображение и обеспечивающего работу элементов.
4.       Создать и проверить работу модального диалогового окна, обеспечивающего чтение выбранного в стандартном диалоге текстового файла и отображение его содержимого в поле редактора.

Выполнение работы:
Создан проект SP_PR5 типа Win32 Application. Добавлены необходимые файлы для создания приложения с главным окном и обработкой сообщений WM_CREATE, WM_PAINT, WM_DESTROY, WM_COMMAND (взяты файлы с исходными текстами из предыдущей работы). Для вызова обработчиков сообщений в оконной процедуре использована макрокоманда HANDLE_MSG;
…
LRESULT CALLBACK WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        HANDLE_MSG(hWnd, WM_CREATE, OnCreate);                 // При создании окна
        HANDLE_MSG(hWnd, WM_COMMAND, OnCommand);               // При выполнении команды (меню, кнопки)
        HANDLE_MSG(hWnd, WM_DESTROY, OnDestroy);               // При уничтожении окна
        HANDLE_MSG(hWnd, WM_PAINT, OnPaint);                   // Перерисовка окна
        HANDLE_MSG(hWnd, WM_LBUTTONDOWN, OnLButtonDown);       // Левый клик мыши
        HANDLE_MSG(hWnd, WM_RBUTTONDOWN, OnRButtonDown);       // Правый клик мыши

…
Добавлено в приложение меню с элементами "Файл", "Просмотр", "Справка".
В меню "Файл" включена команда с именем "Выход \tAlt+x" (идентификатор IDM_FILE_EXIT).
В меню "Просмотр" включена команда "Текст" (идентификатор IDM_VIEW_TEXT) и "Элементы управления" (идентификатор IDM_VIEW_CTL).
В меню "Справка" включена команда "О программе...".
Подключено меню к окну приложения.
 
     Добавлены ветви «case» в обработчик сообщения WM_COMMAND для вышеуказанных команд меню – заглушки, содержащие вызов функции MessageBox с выводом текста "Выбрана команда ХХХ", где ХХХ - имя соответствующего элемента-команды в меню;
void OnCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify)
{
    switch (id)
    {
    case IDCANCEL:
    case IDM_FILE_EXIT:
        DestroyWindow(hWnd);     // Закрытие главного окна => завершение программы
        break;

    case IDM_FILE_NEW:
        MessageBox(hWnd, TEXT("Создан новый документ"), TEXT("Меню Файл"), MB_OK);
        // Разблокируем пункты меню
        EnableMenuItem(g_hEditMenu, IDM_EDIT_SELECT, MF_BYCOMMAND | MF_ENABLED);
        EnableMenuItem(g_hFileMenu, IDM_FILE_CLOSE, MF_BYCOMMAND | MF_ENABLED);
        break;

    case IDM_FILE_OPEN:
        MessageBox(hWnd, TEXT("Выбрана команда 'Открыть'"), TEXT("Меню Файл"), MB_OK);
        break;

    case IDM_EDIT_SELECT:
        MessageBox(hWnd, TEXT("Текст выделен"), TEXT("Меню Правка"), MB_OK);
        EnableMenuItem(g_hEditMenu, IDM_EDIT_COPY, MF_BYCOMMAND | MF_ENABLED);
        break;

    case IDM_EDIT_COPY:
        MessageBox(hWnd, TEXT("Текст скопирован"), TEXT("Меню Правка"), MB_OK);
        break;

    case IDM_FILE_CLOSE:
        MessageBox(hWnd, TEXT("Документ закрыт"), TEXT("Меню Файл"), MB_OK);
        // Блокируем пункты меню "Правка" и "Закрыть документ"
        for (int i = 0; i < 4; i++) {
            EnableMenuItem(g_hEditMenu, i, MF_BYPOSITION | MF_GRAYED);
        }
        EnableMenuItem(g_hFileMenu, IDM_FILE_CLOSE, MF_BYCOMMAND | MF_GRAYED);
        break;

    case IDM_HELP_HELP:
        MessageBox(hWnd, TEXT("Выбрана команда 'Помощь'"), TEXT("Меню Справка"), MB_OK);
        break;

    case IDM_HELP_ABOUT:
        // Показываем модальный диалог "О программе"
        DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, AboutProc);
        break;

    case IDM_VIEW_TEXT:
        DialogBox(g_hInst, MAKEINTRESOURCE(IDD_TEXTVIEWER), hWnd, TextViewerProc);
        break;

    case IDM_VIEW_CTL:
        DialogBox(g_hInst, MAKEINTRESOURCE(IDD_CONTROLS), hWnd, ControlsProc);
        InvalidateRect(hWnd, NULL, TRUE); // Перерисовать окно
        break;

    case IDM_VIEW_MODELESS:
        if (g_hModelessDlg == NULL)
        {
            // Создаем немодальный диалог, если еще не создан
            g_hModelessDlg = CreateDialog(g_hInst, MAKEINTRESOURCE(IDD_MODELESS), hWnd, ModelessProc);
            if (g_hModelessDlg == NULL)
            {
                MessageBox(hWnd, TEXT("Не удалось создать немодальный диалог"), TEXT("Ошибка"), MB_OK);
            }
        }
        else
        {
            // Если открыт - показываем и ставим на передний план
            SetForegroundWindow(g_hModelessDlg);
        }
        break;
    }
}

      Реализована команда "Выход": {... DestroyWindow(hWnd);};
INT_PTR CALLBACK ModelessProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:
        return (INT_PTR)TRUE;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDCANCEL)
        {
            DestroyWindow(hDlg);        // Уничтожаем окно диалога при закрытии
            g_hModelessDlg = NULL;      // Очищаем глобальный хендл
            return (INT_PTR)TRUE;
        }
        break;

    case WM_CLOSE:
        DestroyWindow(hDlg);
        g_hModelessDlg = NULL;
        return (INT_PTR)TRUE;
    }
    return (INT_PTR)FALSE;
}

 

Создание диалогового окна “О программе...”
В диалоговом окне отображаются иконка, сведения о программе, сведения об авторе и текущие дата и время.
 
 
Создание модального диалога с элементами управления Edit, ListBox, Button.
Диалог открывается по команде "Элементы управления" из меню "Просмотр". В диалоговом окне осуществляется отображение и обеспечивается работа элементов управления: ввод текста в редакторе; по нажатию кнопки «Читать» чтение строки из поля редактора и сохранение в символьном массиве; по нажатию кнопки «Добавить» обеспечивается добавление строки в список. При нажатии кнопки «Да» введенные данные сохраняются в глобальном массиве строк и завершается работа диалогового окна. После закрытия диалогового окна отображаются введенные строки в главном окне. По кнопке «Отменить» завершается диалог без сохранения данных.
 
      Создание модального диалога для отображения текстового файла
Создать модальное диалоговое окно с редактором текста, кнопкой «OK» и кнопкой «Загрузить». В начальном состоянии фокус ввода передан кнопке «Загрузить», а в поле редактора отображается текст «Шаг 1. Начало работы». При нажатии на кнопку реализуется чтение выбранного в стандартном диалоге «Open File» текстового файла и отображение его содержимого в поле редактора.
   
Диалоговое окно открывается по команде "Текст" из меню "Просмотр".

https://github.com/Maxevgen555/SP_PR15-PR17
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).

Вывод: 
В процессе выполнения лабораторной работы я научился с помощью кода создавать обработки сообщений в приложении с графическим интерфейсом, обеспечивать перерисовку окна, выводить текст в окно посредством обработки сообщений мыши, создавать 
элементы управления в главном окне, обработки извещения WM_COMMAND.







Лабораторная работа №16 

Вариант №3
 Обработка сообщений мыши и клавиатуры.

Цели лабораторной работы:
Изучить работу приложения КeyDemo, обработку сообщений мыши и клавиатуры.

Задание:
1. Изучить работу приложения КeyDemo. Для чего:
– создать новый пустой проект Win32 приложения на C++;
– скопировать в папку проекта из папки лабораторной работы файл KeyDemo.cpp ;
– выполнить сборку проекта, изучить исходный текст приложения и проанализировать его работу.
 
2. Дополнил обработку сообщений от мыши кодом, который при перемещении курсора мыши в левом верхнем углу будет выводить текущие координаты мыши, взятые из параметра lParam, а при передвижении мыши c нажатой левой кнопкой на экран будет выводиться ее след.
Основные изменения:
Добавлены глобальные переменные:
- std::vector<POINT> g_mouseTrail - для хранения точек следа мыши
- const int MAX_TRAIL_POINTS = 1000 - максимальное количество точек следа
Модифицирован обработчик km_OnMouseMove:
- Добавлен вывод координат в левом верхнем углу окна (когда x и y меньше 100)
- Добавлено сохранение точек траектории при движении с нажатой левой кнопкой мыши
- Добавлен вызов InvalidateRect для перерисовки окна при добавлении новых точек
- Модифицирован обработчик km_OnPaint:
- Добавлено рисование следа мыши с помощью линий между сохраненными точками
- Использовано красное перо для визуального выделения следа
 
3. Разработано приложение, в котором: 
1. Создается окно-рамка размера ( CX х CY) c координатами верхнего левого угла X0 и Y0 относительно левого верхнего угла клиентской области родительского окна; 
2. При нажатии клавиш К1, К2,К3, К4 окно рамка перемещается на d пиксел влево, вправо, вверх, вниз. Координаты левого верхнего угла рамки выводить в нижней части клиентской области главного окна цветом CF ; 
3. При нажатии клавиши F2 включается режим рисования следа мыши; 
4. При нажатии F3 выключается режим рисования следа; 
5. При включенном режиме рисования и нажатой левой кнопки мыши в окне-рамке отображается трасса перемещения курсора мыши. Для обозначения трассы курсора выводится фигуру- маркер F. Маркер выводится цветом CF и только для каждого n -го сообщения о перемещении мыши. 
Вариант 3, значения X0 Y0 Cx Cy K1 K2 K3 K4 D F N CF:
 30 130 150 300 D F C V 1 прямоугольник 5 синий
 

https://github.com/Maxevgen555/SP_PR15-PR17
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).

Вывод: 
В процессе выполнения лабораторной работы я научился обработке сообщений мыши и клавиатуры.






Лабораторная работа №17 

Вариант №3
Тема: Графический вывод
Цели лабораторной работы:
Изучить вывод текста в окно, вывод в окно графического изображения.

Задание:
1. Разработана программу, которая осуществляет:
а) вывод текста в окно. В качестве выводимого текста взяты мои фамилия, имя и отчество;
// Функция рисования содержимого
void DrawContent(HDC hdc, int x, int y) {
    // Создаем и выбираем шрифт
    HFONT hFont = CreateFont(28, 0, 0, 0, FW_BOLD, FALSE, FALSE, FALSE,
        DEFAULT_CHARSET, OUT_OUTLINE_PRECIS, CLIP_DEFAULT_PRECIS,
        CLEARTYPE_QUALITY, VARIABLE_PITCH, _T("Times New Roman"));
    HFONT hOldFont = (HFONT)SelectObject(hdc, hFont);  // Сохраняем старый шрифт

    // Устанавливаем цвет текста (зеленый)
    SetTextColor(hdc, RGB(0, 255, 0));

    // Выводим текст (замените на ваши ФИО)
    TextOut(hdc, x, y, _T("Гончаров Максим Евгеньевич"), 29);
 
б) вывод в окно графического изображения. Параметры рисования взяты в соответствии с заданным вариантом из таблицы 2. Вариант задания определяет номер фигуры в таблице 3, толщину линий для рисования, радиус окружности R, размеры сторон A и B, цвет линии контура фигуры, цвет закраски внутренней поверхности и вариант штриховки из таблицы 4. Если вариант штриховки не задан в таблице 2, то штриховка должна соответствовать изображению в таблице 3.
  
 
    // Параметры фигуры
    int A = 60;  // Сторона квадрата
    int R = A / 2;  // Радиус полукруга (30)

    // Смещаем точку рисования фигуры ниже текста
    int figureY = y + 60;

    // Создаем перо для контура (синий, толщина 2)
    HPEN hPen = CreatePen(PS_SOLID, 2, RGB(0, 0, 255));
    HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);  // Сохраняем старое перо

    // Рисуем квадрат с диагональной штриховкой (сетка 45 и 135 градусов)
    HBRUSH hSquareBrush = CreateHatchBrush(HS_DIAGCROSS, RGB(0, 255, 0));
    HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, hSquareBrush);  // Сохраняем старую кисть

    // Рисуем квадрат
    Rectangle(hdc, x, figureY, x + A, figureY + A);

    // Рисуем полукруг с горизонтальной штриховкой
    HBRUSH hSemiCircleBrush = CreateHatchBrush(HS_HORIZONTAL, RGB(0, 255, 0));
    SelectObject(hdc, hSemiCircleBrush);  // Выбираем кисть для полукруга

    // Создаем регион для полукруга (верхняя половина эллипса)
    HRGN hSemiCircleRgn = CreateEllipticRgn(x, figureY - R, x + 2 * R, figureY + R);

    // Создаем прямоугольный регион для обрезки верхней части эллипса
    HRGN hRectRgn = CreateRectRgn(x, figureY - R, x + 2 * R, figureY);

    // Обрезаем эллипс, оставляя только верхнюю половину (полукруг)
    CombineRgn(hSemiCircleRgn, hSemiCircleRgn, hRectRgn, RGN_AND);

    // Закрашиваем регион полукруга горизонтальной штриховкой
    FillRgn(hdc, hSemiCircleRgn, hSemiCircleBrush);

    // Рисуем контур полукруга (дугу)
    Arc(hdc, x, figureY - R, x + 2 * R, figureY + R,
        x + 2 * R, figureY, x, figureY);

2. Разработан вариант программы с сохранением вывода в виде метафайла и обеспечением возможности его воспроизведения в последующем.
 
// Функция сохранения как метафайла
void SaveAsMetafile(HWND hWnd) {
    // Создаем контекст метафайла
    HDC hMetaDC = CreateEnhMetaFile(NULL, _T("output.emf"), NULL, _T("Graphic Output"));

    if (hMetaDC) {
        // Рисуем содержимое в метафайл
        DrawContent(hMetaDC, 50, 50);

        // Завершаем создание метафайла
        HENHMETAFILE hemf = CloseEnhMetaFile(hMetaDC);

        if (hemf) {
            MessageBox(hWnd, _T("Метафайл успешно сохранен как output.emf"), _T("Успех"), MB_OK);
            DeleteEnhMetaFile(hemf);  // Удаляем метафайл из памяти
        }
        else {
            MessageBox(hWnd, _T("Ошибка при сохранении метафайла"), _T("Ошибка"), MB_OK | MB_ICONERROR);
        }
    }
}

3. Разработана программа для вывода в дочернее или диалоговое окно графического изображения из ресурсов приложения или из внешнего файла. 
 
// Функция отображения метафайла
void DisplayImage(HWND hWnd) {
    // Регистрируем класс дочернего окна
    WNDCLASSEX wc = { 0 };
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc = ChildWndProc;
    wc.hInstance = hInst;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = szChildClassName;

    RegisterClassEx(&wc);

    // Создаем дочернее окно
    HWND hChild = CreateWindow(szChildClassName, _T("Метафайл"),
        WS_OVERLAPPEDWINDOW | WS_CHILD,  // Стиль окна - дочернее
        CW_USEDEFAULT, CW_USEDEFAULT,
        400, 300, hWnd, NULL, hInst, NULL);
    if (hChild) {
        ShowWindow(hChild, SW_SHOW);
        UpdateWindow(hChild);
    }
}

// Процедура дочернего окна для отображения метафайла
LRESULT CALLBACK ChildWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) {
    switch (message) {
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hWnd, &ps);  // Получаем контекст устройства

        // Загружаем метафайл
        HENHMETAFILE hemf = GetEnhMetaFile(_T("output.emf"));

        if (hemf) {
            // Получаем размеры клиентской области
            RECT rect;
            GetClientRect(hWnd, &rect);

            // Воспроизводим метафайл
            PlayEnhMetaFile(hdc, hemf, &rect);

            // Удаляем метафайл
            DeleteEnhMetaFile(hemf);
        }
        else {
            // Если метафайл не загружен, выводим сообщение
            TextOut(hdc, 10, 10, _T("Метафайл output.emf не найден"), 26);
        }

        EndPaint(hWnd, &ps);  // Завершаем перерисовку
        break;
    }

https://github.com/Maxevgen555/SP_PR15-PR17
При работе использовались ии-агенты https://chat.deepseek.com/  https://www.perplexity.ai/ и copilot (встроенный клиент VS2024, отдельно установленная программа).

Вывод: 
В ходе работы был изучен вывод текста в окно, вывод в окно графического изображения, сохранение вывода в виде метафайла и обеспечением возможности его воспроизведения в последующем.


